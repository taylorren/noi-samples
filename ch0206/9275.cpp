#include <bits/stdc++.h>
using namespace std;

const int mod = 5000011;
int f[100010][2], n, m;

int main()
{
    int i, j;
    cin >> n >> m;
    //[][0]表示奶牛，[][1]表示公牛
    // 初始状态：只有一头牛，当然只有一种排列方法：一头奶牛或者一头公牛
    f[1][1] = f[1][0] = 1;

    for(i = 2; i <= n; ++i)
    {
        // 如果第 i 个位置是奶牛，那么前一个位置可以是奶牛或公牛。
        // 因此，f[i][0]等于前一个位置以奶牛结尾的方法数加上前一个位置以公牛结尾的方法数。
        f[i][0] = f[i - 1][0] + f[i - 1][1];
        f[i][0] %= mod;

        // 如果第 i 个位置是公牛，那么前一个位置只能是奶牛。
        // 此时，f[i][1]
        // 表示以公牛结尾的排列方法数，初始值为前一个位置的公牛结尾方法数。
        // 后续通过累加 f[x][1] 来确保公牛之间至少有 m 只奶牛的限制。
        f[i][1] = (f[i - 1][1]) % mod;

        int x = i - m - 1;
        if(x > 0)
        {
            f[i][1] = (f[i][1] + f[x][1]) % mod;
        }
    }

    cout << (f[n][0] + f[n][1]) % mod << endl;

    return 0;
}

/*dp[i][0]表示位置i不放公牛，dp[i][1]表示位置i放公牛。

　　当位置i不放公牛，位置i-1对其不产生影响，所以dp[i][0]可以从dp[i-1][0]和dp[i-1][1]转移过来。

　　当位置i放公牛，位置i-M一定不能放公牛，所以dp[i][1]可以从dp[i-M][0]转移过来。

　　还有一个难点在预处理上。在1~M中如果位置i放一头公牛那么就只能放那一头公牛，所以dp[i][1]=1。如果位置i不放牛，那么放公牛的方案就有i-1种，不放公牛的方案有1种，所以dp[i][0]=i-1+1=i。

　　总结一下，预处理时dp[i][1]=1，dp[i][0]=i；DP时dp[i][0]=dp[i-1][0]+dp[i-1][1]，dp[i][1]=dp[i-M][0]。
*/