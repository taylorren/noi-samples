#include <bits/stdc++.h>
using namespace std;

int f[2000010];
int main()
{
    int n, t;
    f[1] = 1;
    f[2] = 2;
    int s = 1;
    for(int i = 3; i <= 200000; ++i)
    {
        s += f[i - 1];
        s %= 100000;
        f[i] += f[i - 1] + s;
        f[i] %= 100000;
    }

    cin>>t;

    for(int i = 1; i <= t; i++)
    {
        cin>>n;
        cout<<f[n]<<endl;
    }

    return 0;
}

/*f[i]=f[i-1]*1+f[i-2]*2+f[i-3]*3+.....+f[1]*(i-1)
f[i+1]=f[i]*1+f[i-1]*2+f[i-2]*3+.......+f[1]*i
发现他们的区别了吗！！发现了吗！！！没发现两式相减看看结果！嗯。每次发现都是多加了一组f[1]到f[i]。
好了！我们前缀和的方法，就是这个突破口。每次在动态维护数组f的时候，用一个动态的变量s来记录f[1]到f[i]的和。这样的话，就减去了很多重复的加法运算。*/